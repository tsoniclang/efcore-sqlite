// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.DependencyModel
// Assembly: Microsoft.Extensions.DependencyModel

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ICompilationAssemblyResolver } from "../../Microsoft.Extensions.DependencyModel.Resolution/internal/index.js";
import type { IEnumerable, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, IDisposable, IEquatable, Int32, Nullable, Object as ClrObject, String as ClrString, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Assembly, AssemblyName } from "@tsonic/dotnet/System.Reflection.js";

export interface IDependencyContextReader$instance extends IDisposable {
    read(stream: Stream): DependencyContext;
}


export type IDependencyContextReader = IDependencyContextReader$instance;

export interface Dependency$instance {
    readonly name: string;
    readonly version: string;
    equals(other: Dependency): boolean;
    equals(obj: unknown): boolean;
    getHashCode(): int;
}


export const Dependency: {
    new(name: string, version: string): Dependency;
};


export type Dependency = Dependency$instance;

export interface CompilationLibrary$instance extends Library {
    readonly assemblies: IReadOnlyList<System_Internal.String>;
    resolveReferencePaths(): IEnumerable<System_Internal.String>;
    resolveReferencePaths(...customResolvers: ICompilationAssemblyResolver[]): IEnumerable<System_Internal.String>;
}


export const CompilationLibrary: {
    new(type: string, name: string, version: string, hash: string, assemblies: IEnumerable<System_Internal.String>, dependencies: IEnumerable<Dependency>, serviceable: boolean): CompilationLibrary;
    new(type: string, name: string, version: string, hash: string, assemblies: IEnumerable<System_Internal.String>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): CompilationLibrary;
};


export type CompilationLibrary = CompilationLibrary$instance;

export interface CompilationOptions$instance {
    readonly allowUnsafe: Nullable<System_Internal.Boolean>;
    readonly debugType: string | undefined;
    readonly defines: IReadOnlyList<string | undefined>;
    readonly delaySign: Nullable<System_Internal.Boolean>;
    readonly emitEntryPoint: Nullable<System_Internal.Boolean>;
    readonly generateXmlDocumentation: Nullable<System_Internal.Boolean>;
    readonly keyFile: string | undefined;
    readonly languageVersion: string | undefined;
    readonly optimize: Nullable<System_Internal.Boolean>;
    readonly platform: string | undefined;
    readonly publicSign: Nullable<System_Internal.Boolean>;
    readonly warningsAsErrors: Nullable<System_Internal.Boolean>;
}


export const CompilationOptions: {
    new(defines: IEnumerable<System_Internal.String>, languageVersion: string, platform: string, allowUnsafe: Nullable<System_Internal.Boolean>, warningsAsErrors: Nullable<System_Internal.Boolean>, optimize: Nullable<System_Internal.Boolean>, keyFile: string, delaySign: Nullable<System_Internal.Boolean>, publicSign: Nullable<System_Internal.Boolean>, debugType: string, emitEntryPoint: Nullable<System_Internal.Boolean>, generateXmlDocumentation: Nullable<System_Internal.Boolean>): CompilationOptions;
    readonly default: CompilationOptions;
};


export type CompilationOptions = CompilationOptions$instance;

export interface DependencyContext$instance {
    readonly compilationOptions: CompilationOptions;
    readonly compileLibraries: IReadOnlyList<CompilationLibrary>;
    readonly runtimeGraph: IReadOnlyList<RuntimeFallbacks>;
    readonly runtimeLibraries: IReadOnlyList<RuntimeLibrary>;
    readonly target: TargetInfo;
    merge(other: DependencyContext): DependencyContext;
}


export const DependencyContext: {
    new(target: TargetInfo, compilationOptions: CompilationOptions, compileLibraries: IEnumerable<CompilationLibrary>, runtimeLibraries: IEnumerable<RuntimeLibrary>, runtimeGraph: IEnumerable<RuntimeFallbacks>): DependencyContext;
    readonly default: DependencyContext | undefined;
    load(assembly: Assembly): DependencyContext | undefined;
};


export type DependencyContext = DependencyContext$instance;

export interface DependencyContextJsonReader$instance {
    dispose(): void;
    read(stream: Stream): DependencyContext;
}


export const DependencyContextJsonReader: {
    new(): DependencyContextJsonReader;
};


export interface __DependencyContextJsonReader$views {
    As_IDependencyContextReader(): IDependencyContextReader$instance;
}

export interface DependencyContextJsonReader$instance extends IDependencyContextReader$instance {}

export type DependencyContextJsonReader = DependencyContextJsonReader$instance & __DependencyContextJsonReader$views;


export interface DependencyContextLoader$instance {
    load(assembly: Assembly): DependencyContext | undefined;
}


export const DependencyContextLoader: {
    new(): DependencyContextLoader;
    readonly default: DependencyContextLoader;
};


export type DependencyContextLoader = DependencyContextLoader$instance;

export interface DependencyContextWriter$instance {
    write(context: DependencyContext, stream: Stream): void;
}


export const DependencyContextWriter: {
    new(): DependencyContextWriter;
};


export type DependencyContextWriter = DependencyContextWriter$instance;

export interface Library$instance {
    readonly dependencies: IReadOnlyList<Dependency>;
    readonly hash: string | undefined;
    readonly hashPath: string | undefined;
    readonly name: string;
    readonly path: string;
    readonly runtimeStoreManifestName: string | undefined;
    readonly serviceable: boolean;
    readonly type: string;
    readonly version: string;
}


export const Library: {
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean): Library;
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): Library;
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string, runtimeStoreManifestName: string): Library;
};


export type Library = Library$instance;

export interface ResourceAssembly$instance {
    locale: string;
    readonly localPath: string | undefined;
    path: string;
}


export const ResourceAssembly: {
    new(path: string, locale: string): ResourceAssembly;
    new(path: string, locale: string, localPath: string): ResourceAssembly;
};


export type ResourceAssembly = ResourceAssembly$instance;

export interface RuntimeAssembly$instance {
    readonly name: AssemblyName;
    readonly path: string;
}


export const RuntimeAssembly: {
    new(assemblyName: string, path: string): RuntimeAssembly;
    create(path: string): RuntimeAssembly;
};


export type RuntimeAssembly = RuntimeAssembly$instance;

export interface RuntimeAssetGroup$instance {
    readonly assetPaths: IReadOnlyList<System_Internal.String>;
    readonly runtime: string;
    readonly runtimeFiles: IReadOnlyList<RuntimeFile>;
}


export const RuntimeAssetGroup: {
    new(runtime: string, assetPaths: string[]): RuntimeAssetGroup;
    new(runtime: string, assetPaths: IEnumerable<System_Internal.String>): RuntimeAssetGroup;
    new(runtime: string, runtimeFiles: IEnumerable<RuntimeFile>): RuntimeAssetGroup;
};


export type RuntimeAssetGroup = RuntimeAssetGroup$instance;

export interface RuntimeFallbacks$instance {
    fallbacks: IReadOnlyList<string | undefined>;
    runtime: string;
}


export const RuntimeFallbacks: {
    new(runtime: string, fallbacks: string[]): RuntimeFallbacks;
    new(runtime: string, fallbacks: IEnumerable<System_Internal.String>): RuntimeFallbacks;
};


export type RuntimeFallbacks = RuntimeFallbacks$instance;

export interface RuntimeFile$instance {
    readonly assemblyVersion: string | undefined;
    readonly fileVersion: string | undefined;
    readonly localPath: string | undefined;
    readonly path: string;
}


export const RuntimeFile: {
    new(path: string, assemblyVersion: string, fileVersion: string): RuntimeFile;
    new(path: string, assemblyVersion: string, fileVersion: string, localPath: string): RuntimeFile;
};


export type RuntimeFile = RuntimeFile$instance;

export interface RuntimeLibrary$instance extends Library {
    readonly nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>;
    readonly resourceAssemblies: IReadOnlyList<ResourceAssembly>;
    readonly runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>;
}


export const RuntimeLibrary: {
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean): RuntimeLibrary;
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): RuntimeLibrary;
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string, runtimeStoreManifestName: string): RuntimeLibrary;
};


export type RuntimeLibrary = RuntimeLibrary$instance;

export interface TargetInfo$instance {
    readonly framework: string;
    readonly isPortable: boolean;
    readonly runtime: string;
    readonly runtimeSignature: string | undefined;
}


export const TargetInfo: {
    new(framework: string, runtime: string, runtimeSignature: string, isPortable: boolean): TargetInfo;
};


export type TargetInfo = TargetInfo$instance;

export abstract class DependencyContextExtensions$instance {
    static getDefaultAssemblyNames(self: DependencyContext): IEnumerable<AssemblyName>;
    static getDefaultAssemblyNames(self: RuntimeLibrary, context: DependencyContext): IEnumerable<AssemblyName>;
    static getDefaultNativeAssets(self: DependencyContext): IEnumerable<System_Internal.String>;
    static getDefaultNativeAssets(self: RuntimeLibrary, context: DependencyContext): IEnumerable<System_Internal.String>;
    static getDefaultNativeRuntimeFileAssets(self: DependencyContext): IEnumerable<RuntimeFile>;
    static getDefaultNativeRuntimeFileAssets(self: RuntimeLibrary, context: DependencyContext): IEnumerable<RuntimeFile>;
    static getRuntimeAssemblyNames(self: DependencyContext, runtimeIdentifier: string): IEnumerable<AssemblyName>;
    static getRuntimeAssemblyNames(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<AssemblyName>;
    static getRuntimeNativeAssets(self: DependencyContext, runtimeIdentifier: string): IEnumerable<System_Internal.String>;
    static getRuntimeNativeAssets(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<System_Internal.String>;
    static getRuntimeNativeRuntimeFileAssets(self: DependencyContext, runtimeIdentifier: string): IEnumerable<RuntimeFile>;
    static getRuntimeNativeRuntimeFileAssets(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<RuntimeFile>;
}


export type DependencyContextExtensions = DependencyContextExtensions$instance;

