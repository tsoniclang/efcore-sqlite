// Generated by tsbindgen - Architecture
// Namespace: Microsoft.Extensions.DependencyModel
// Assembly: Microsoft.Extensions.DependencyModel

// Primitive type aliases from @tsonic/core
import type { sbyte, byte, short, ushort, int, uint, long, ulong, int128, uint128, half, float, double, decimal, nint, nuint, char } from '@tsonic/core/types.js';

// Import types from other namespaces
import type { ICompilationAssemblyResolver } from "../../Microsoft.Extensions.DependencyModel.Resolution/internal/index.js";
import type { IEnumerable, IReadOnlyList } from "@tsonic/dotnet/System.Collections.Generic.js";
import type { Stream } from "@tsonic/dotnet/System.IO.js";
import * as System_Internal from "@tsonic/dotnet/System.js";
import type { Boolean as ClrBoolean, IDisposable, IEquatable, Int32, Nullable, Object as ClrObject, String as ClrString, ValueType, Void } from "@tsonic/dotnet/System.js";
import type { Assembly, AssemblyName } from "@tsonic/dotnet/System.Reflection.js";

export interface IDependencyContextReader$instance extends IDisposable {
    readonly __tsonic_iface_Microsoft_Extensions_DependencyModel_IDependencyContextReader: never;

    Read(stream: Stream): DependencyContext;
}


export interface IDependencyContextReader$instance extends System_Internal.IDisposable {}

export type IDependencyContextReader = IDependencyContextReader$instance;

export interface Dependency$instance {
    readonly __tsonic_iface_System_IEquatable_1: never;

    readonly Name: string;
    readonly Version: string;
    Equals(other: Dependency): boolean;
    Equals(obj: unknown): boolean;
    GetHashCode(): int;
}


export const Dependency: {
    new(name: string, version: string): Dependency;
};


export type Dependency = Dependency$instance;

export interface CompilationLibrary$instance extends Library {
    readonly Assemblies: IReadOnlyList<System_Internal.String>;
    ResolveReferencePaths(): IEnumerable<System_Internal.String>;
    ResolveReferencePaths(...customResolvers: ICompilationAssemblyResolver[]): IEnumerable<System_Internal.String>;
}


export const CompilationLibrary: {
    new(type: string, name: string, version: string, hash: string, assemblies: IEnumerable<System_Internal.String>, dependencies: IEnumerable<Dependency>, serviceable: boolean): CompilationLibrary;
    new(type: string, name: string, version: string, hash: string, assemblies: IEnumerable<System_Internal.String>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): CompilationLibrary;
};


export type CompilationLibrary = CompilationLibrary$instance;

export interface CompilationOptions$instance {
    readonly AllowUnsafe: Nullable<System_Internal.Boolean>;
    readonly DebugType: string | undefined;
    readonly Defines: IReadOnlyList<string | undefined>;
    readonly DelaySign: Nullable<System_Internal.Boolean>;
    readonly EmitEntryPoint: Nullable<System_Internal.Boolean>;
    readonly GenerateXmlDocumentation: Nullable<System_Internal.Boolean>;
    readonly KeyFile: string | undefined;
    readonly LanguageVersion: string | undefined;
    readonly Optimize: Nullable<System_Internal.Boolean>;
    readonly Platform: string | undefined;
    readonly PublicSign: Nullable<System_Internal.Boolean>;
    readonly WarningsAsErrors: Nullable<System_Internal.Boolean>;
}


export const CompilationOptions: {
    new(defines: IEnumerable<System_Internal.String>, languageVersion: string, platform: string, allowUnsafe: Nullable<System_Internal.Boolean>, warningsAsErrors: Nullable<System_Internal.Boolean>, optimize: Nullable<System_Internal.Boolean>, keyFile: string, delaySign: Nullable<System_Internal.Boolean>, publicSign: Nullable<System_Internal.Boolean>, debugType: string, emitEntryPoint: Nullable<System_Internal.Boolean>, generateXmlDocumentation: Nullable<System_Internal.Boolean>): CompilationOptions;
    readonly Default: CompilationOptions;
};


export type CompilationOptions = CompilationOptions$instance;

export interface DependencyContext$instance {
    readonly CompilationOptions: CompilationOptions;
    readonly CompileLibraries: IReadOnlyList<CompilationLibrary>;
    readonly RuntimeGraph: IReadOnlyList<RuntimeFallbacks>;
    readonly RuntimeLibraries: IReadOnlyList<RuntimeLibrary>;
    readonly Target: TargetInfo;
    Merge(other: DependencyContext): DependencyContext;
}


export const DependencyContext: {
    new(target: TargetInfo, compilationOptions: CompilationOptions, compileLibraries: IEnumerable<CompilationLibrary>, runtimeLibraries: IEnumerable<RuntimeLibrary>, runtimeGraph: IEnumerable<RuntimeFallbacks>): DependencyContext;
    readonly Default: DependencyContext | undefined;
    Load(assembly: Assembly): DependencyContext | undefined;
};


export type DependencyContext = DependencyContext$instance;

export interface DependencyContextJsonReader$instance {
    readonly __tsonic_iface_Microsoft_Extensions_DependencyModel_IDependencyContextReader: never;
    readonly __tsonic_iface_System_IDisposable: never;

    Dispose(disposing: boolean): void;
    Dispose(): void;
    Read(stream: Stream): DependencyContext;
}


export const DependencyContextJsonReader: {
    new(): DependencyContextJsonReader;
};


export interface __DependencyContextJsonReader$views {
    As_IDependencyContextReader(): IDependencyContextReader$instance;
}

export interface DependencyContextJsonReader$instance extends IDependencyContextReader$instance {}

export type DependencyContextJsonReader = DependencyContextJsonReader$instance & __DependencyContextJsonReader$views;


export interface DependencyContextLoader$instance {
    Load(assembly: Assembly): DependencyContext | undefined;
}


export const DependencyContextLoader: {
    new(): DependencyContextLoader;
    readonly Default: DependencyContextLoader;
};


export type DependencyContextLoader = DependencyContextLoader$instance;

export interface DependencyContextWriter$instance {
    Write(context: DependencyContext, stream: Stream): void;
}


export const DependencyContextWriter: {
    new(): DependencyContextWriter;
};


export type DependencyContextWriter = DependencyContextWriter$instance;

export interface Library$instance {
    readonly Dependencies: IReadOnlyList<Dependency>;
    readonly Hash: string | undefined;
    readonly HashPath: string | undefined;
    readonly Name: string;
    readonly Path: string | undefined;
    readonly RuntimeStoreManifestName: string | undefined;
    readonly Serviceable: boolean;
    readonly Type: string;
    readonly Version: string;
}


export const Library: {
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean): Library;
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): Library;
    new(type: string, name: string, version: string, hash: string, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string, runtimeStoreManifestName: string): Library;
};


export type Library = Library$instance;

export interface ResourceAssembly$instance {
    Locale: string;
    readonly LocalPath: string | undefined;
    Path: string;
}


export const ResourceAssembly: {
    new(path: string, locale: string): ResourceAssembly;
    new(path: string, locale: string, localPath: string): ResourceAssembly;
};


export type ResourceAssembly = ResourceAssembly$instance;

export interface RuntimeAssembly$instance {
    readonly Name: AssemblyName;
    readonly Path: string;
}


export const RuntimeAssembly: {
    new(assemblyName: string, path: string): RuntimeAssembly;
    Create(path: string): RuntimeAssembly;
};


export type RuntimeAssembly = RuntimeAssembly$instance;

export interface RuntimeAssetGroup$instance {
    readonly AssetPaths: IReadOnlyList<System_Internal.String>;
    readonly Runtime: string | undefined;
    readonly RuntimeFiles: IReadOnlyList<RuntimeFile>;
}


export const RuntimeAssetGroup: {
    new(runtime: string, assetPaths: string[]): RuntimeAssetGroup;
    new(runtime: string, assetPaths: IEnumerable<System_Internal.String>): RuntimeAssetGroup;
    new(runtime: string, runtimeFiles: IEnumerable<RuntimeFile>): RuntimeAssetGroup;
};


export type RuntimeAssetGroup = RuntimeAssetGroup$instance;

export interface RuntimeFallbacks$instance {
    Fallbacks: IReadOnlyList<string | undefined>;
    Runtime: string;
}


export const RuntimeFallbacks: {
    new(runtime: string, fallbacks: string[]): RuntimeFallbacks;
    new(runtime: string, fallbacks: IEnumerable<System_Internal.String>): RuntimeFallbacks;
};


export type RuntimeFallbacks = RuntimeFallbacks$instance;

export interface RuntimeFile$instance {
    readonly AssemblyVersion: string | undefined;
    readonly FileVersion: string | undefined;
    readonly LocalPath: string | undefined;
    readonly Path: string;
}


export const RuntimeFile: {
    new(path: string, assemblyVersion: string, fileVersion: string): RuntimeFile;
    new(path: string, assemblyVersion: string, fileVersion: string, localPath: string): RuntimeFile;
};


export type RuntimeFile = RuntimeFile$instance;

export interface RuntimeLibrary$instance extends Library {
    readonly NativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>;
    readonly ResourceAssemblies: IReadOnlyList<ResourceAssembly>;
    readonly RuntimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>;
}


export const RuntimeLibrary: {
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean): RuntimeLibrary;
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string): RuntimeLibrary;
    new(type: string, name: string, version: string, hash: string, runtimeAssemblyGroups: IReadOnlyList<RuntimeAssetGroup>, nativeLibraryGroups: IReadOnlyList<RuntimeAssetGroup>, resourceAssemblies: IEnumerable<ResourceAssembly>, dependencies: IEnumerable<Dependency>, serviceable: boolean, path: string, hashPath: string, runtimeStoreManifestName: string): RuntimeLibrary;
};


export type RuntimeLibrary = RuntimeLibrary$instance;

export interface TargetInfo$instance {
    readonly Framework: string;
    readonly IsPortable: boolean;
    readonly Runtime: string | undefined;
    readonly RuntimeSignature: string | undefined;
}


export const TargetInfo: {
    new(framework: string, runtime: string, runtimeSignature: string, isPortable: boolean): TargetInfo;
};


export type TargetInfo = TargetInfo$instance;

export abstract class DependencyContextExtensions$instance {
    static GetDefaultAssemblyNames(self: DependencyContext): IEnumerable<AssemblyName>;
    static GetDefaultAssemblyNames(self: RuntimeLibrary, context: DependencyContext): IEnumerable<AssemblyName>;
    static GetDefaultNativeAssets(self: DependencyContext): IEnumerable<System_Internal.String>;
    static GetDefaultNativeAssets(self: RuntimeLibrary, context: DependencyContext): IEnumerable<System_Internal.String>;
    static GetDefaultNativeRuntimeFileAssets(self: DependencyContext): IEnumerable<RuntimeFile>;
    static GetDefaultNativeRuntimeFileAssets(self: RuntimeLibrary, context: DependencyContext): IEnumerable<RuntimeFile>;
    static GetRuntimeAssemblyNames(self: DependencyContext, runtimeIdentifier: string): IEnumerable<AssemblyName>;
    static GetRuntimeAssemblyNames(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<AssemblyName>;
    static GetRuntimeNativeAssets(self: DependencyContext, runtimeIdentifier: string): IEnumerable<System_Internal.String>;
    static GetRuntimeNativeAssets(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<System_Internal.String>;
    static GetRuntimeNativeRuntimeFileAssets(self: DependencyContext, runtimeIdentifier: string): IEnumerable<RuntimeFile>;
    static GetRuntimeNativeRuntimeFileAssets(self: RuntimeLibrary, context: DependencyContext, runtimeIdentifier: string): IEnumerable<RuntimeFile>;
}


export type DependencyContextExtensions = DependencyContextExtensions$instance;

